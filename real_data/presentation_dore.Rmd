---
title: "Présentation de l'application de colSBM sur Doré et al. 2020"
output:
    html_document:
        toc: true
        theme: united
---

```{r require_lib, echo = FALSE, include=FALSE}
require("tidyverse")
require("knitr")
devtools::load_all("R/")
source("wip/temporary_plot.R")
```

```{r pretty_matrix_print, echo = FALSE}
# Define a generic method that transforms an object x in a LaTeX string
as_latex <- function(x, ...) {
  UseMethod("as_latex", x)
}

# Define a class latex for LaTeX expressions
as_latex.character <- function(x) {
  structure(
    paste(x, collapse = " "),
    class = c("latex", "character")
  )
}

# A character string of class latex is rendered in display mode
# Define a knit_print() method for the latex class
knit_print.latex <- function(x, ...) {
  knitr::asis_output(
    paste0("$$", x, "$$")
  )
}

# Now, define a method as_latex for matrix
as_latex.matrix <- function(x, ...) {
  as_latex(c(
    "\\begin{bmatrix}",
    paste(
      t(x),
      rep(c(rep("&", nrow(x) - 1), "\\\\"), ncol(x)),
      collapse = ""
    ),
    "\\end{bmatrix}"
  ))
}

# Indicate to knitr that matrix are rendered as latex
knit_print.matrix <- function(x, ...) {
  knitr::knit_print(as_latex(round(x, 2)))
}
```

```{r taxonomy_functions, echo = FALSE}
interaction_data <- read.table(file = "real_data/data/interaction-data.txt", sep = "\t", header = TRUE)

insect_orders <- unique(interaction_data$insectorder)
plant_family <- unique(interaction_data$plantorder)

insect_orders[is.na(insect_orders)] <- "NA"
plant_family[is.na(plant_family)] <- "NA"
### Matching taxonomy
taxonomy_in_clusters <- function(unlisted_model) {
  if (is.list(unlisted_model)) {
    lapply(seq_len(length(unlisted_model)), function(col_idx) {
      # Per collection
      # Empty init
      insect_count <- t(sapply(insect_orders, function(order) {
        out_count <- rep(0, unlisted_model[[col_idx]]$Q[2])
        out_count
      }))

      plant_count <- t(sapply(plant_family, function(order) {
        out_count <- rep(0, unlisted_model[[col_idx]]$Q[1])
        out_count
      }))

      for (m in seq.int(unlisted_model[[col_idx]]$M)) {
        #### Insect
        insect_names <- names(unlisted_model[[col_idx]]$Z[[1]][[2]])

        insect_count <- insect_count + t(sapply(insect_orders, function(order) {
          out_count <- rep(0, unlisted_model[[col_idx]]$Q[2])
          names(out_count) <- seq.int(unlisted_model[[col_idx]]$Q[2])
          insect_count <- table(unlisted_model[[col_idx]]$Z[[m]][[2]][grep(order, insect_names)])
          out_count[names(insect_count)] <- insect_count
          out_count
        }))
        #### Plants
        plant_names <- names(unlisted_model[[col_idx]]$Z[[1]][[1]])

        plant_count <- t(sapply(plant_family, function(order) {
          out_count <- rep(0, unlisted_model[[col_idx]]$Q[1])
          names(out_count) <- seq.int(unlisted_model[[col_idx]]$Q[1])
          plant_count <- table(unlisted_model[[col_idx]]$Z[[m]][[1]][grep(order, plant_names)])
          out_count[names(plant_count)] <- plant_count
          out_count
        }))
      }
      return(list(insects = insect_count, plants = plant_count))
    })
  } else {
    # Per collection
    # Empty init
    insect_count <- t(sapply(insect_orders, function(order) {
      out_count <- rep(0, unlisted_model$Q[2])
      out_count
    }))

    plant_count <- t(sapply(plant_family, function(order) {
      out_count <- rep(0, unlisted_model$Q[1])
      out_count
    }))

    for (m in seq.int(unlisted_model$M)) {
      #### Insect
      insect_names <- names(unlisted_model$Z[[1]][[2]])

      insect_count <- insect_count + t(sapply(insect_orders, function(order) {
        out_count <- rep(0, unlisted_model$Q[2])
        names(out_count) <- seq.int(unlisted_model$Q[2])
        insect_count <- table(unlisted_model$Z[[m]][[2]][grep(order, insect_names)])
        out_count[names(insect_count)] <- insect_count
        out_count
      }))
      #### Plants
      plant_names <- names(unlisted_model$Z[[1]][[1]])

      plant_count <- t(sapply(plant_family, function(order) {
        out_count <- rep(0, unlisted_model$Q[1])
        names(out_count) <- seq.int(unlisted_model$Q[1])
        plant_count <- table(unlisted_model$Z[[m]][[1]][grep(order, plant_names)])
        out_count[names(plant_count)] <- plant_count
        out_count
      }))
    }
    return(list(list(insects = insect_count, plants = plant_count)))
  }
}

taxonomy_remove_empty <- function(taxonomy_collections_list) {
  lapply(taxonomy_collections_list, function(collection) {
    list(
      insects = collection$insects[which(rowSums(collection$insects != 0) > 0), ],
      plants = collection$plants[which(rowSums(collection$plants != 0) > 0), ]
    )
  })
}

get_formatted_data <- function(collection, group, max_rank = 6) {
  collection[[group]] %>%
    as.data.frame() %>% # Transformation en data frame
    mutate(
      Total = rowSums(.),
      Rang = rank(-Total, ties.method = "min")
    ) %>% # Creation d'une colonne Total
    rownames_to_column(var = "TaxonBrut") %>%
    mutate(Taxon = ifelse(Rang <= max_rank & Total > 0, TaxonBrut, "Other")) %>%
    arrange(Rang) %>%
    mutate(Taxon = factor(Taxon, levels = unique(Taxon))) %>%
    select(-Total, -TaxonBrut, -Rang) %>%
    pivot_longer(
      cols = -c("Taxon"),
      names_to = "Bloc",
      values_to = "Nombre",
      names_prefix = "V"
    ) %>%
    group_by(Taxon, Bloc) %>%
    summarise_all(sum) %>%
    ungroup() %>%
    group_by(Bloc) %>%
    mutate(Proportion = Nombre / sum(Nombre)) %>%
    ungroup() %>%
    mutate(Group = group)
}

taxonomy_plot <- function(data, insects_or_plants, model, stack_or_fill) {
  plots <- filter(data, Group == insects_or_plants) %>%
    ggplot(aes(x = Bloc, y = Nombre, fill = Taxon)) +
    geom_bar(stat = "identity", position = stack_or_fill) +
    labs(x = "Block", y = "Number of Nodes", fill = "Taxonomy") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    ggtitle(paste(
      ifelse(insects_or_plants == "insects",
        "Pollinators", "Plants"
      ), "repartition (",
      ifelse(stack_or_fill == "stack", "absolute", "proportion"),
      ") in the", model, "clustering"
    )) +
    facet_wrap(~Collection, ncol = 3, scales = "free_x")

  # Arrange the plots in a grid layout
  gridExtra::grid.arrange(plots, newpage = TRUE)
}
```

```{r load data, echo = FALSE, include = FALSE}
# All results
iid_clustering <- readRDS("real_data/data/dore_collection_clustering_nb_run1_iid_123networks_24-05-23-21:40:42.Rds")
iid_best_partition <- extract_best_bipartite_partition(iid_clustering)
iid_unlist <- unlist(iid_best_partition)

rho_clustering <- readRDS("real_data/data/dore_collection_clustering_nb_run1_rho_123networks_25-05-23-13:58:30.Rds")
rho_best_partition <- extract_best_bipartite_partition(rho_clustering)
rho_unlist <- unlist(rho_best_partition)

pi_clustering <- readRDS("real_data/data/dore_collection_clustering_nb_run1_pi_123networks_25-05-23-17:31:25.Rds")
pi_best_partition <- extract_best_bipartite_partition(pi_clustering)
pi_unlist <- unlist(pi_best_partition)

pirho_clustering <- readRDS("real_data/data/dore_collection_clustering_nb_run1_pirho_123networks_26-05-23-19:22:55.Rds")
pirho_best_partition <- extract_best_bipartite_partition(pirho_clustering)
pirho_unlist <- unlist(pirho_best_partition)
```

## Clustering avec le modèle iid
Avec le modèle *iid* nous obtenons les `r length(iid_unlist)` collections suivantes:
```{r iid_liste_nom, echo = FALSE, results="asis"}
iid_networks_list <- lapply(seq_along(iid_unlist), function(c) {
  length <- length(iid_unlist[[c]]$net_id)
  data.frame(collection_id = rep(c, length), net_id = iid_unlist[[c]]$net_id)
})
for (df_net in iid_networks_list) {
  print(knitr::kable(df_net))
}
```

Une fois le modèle de collection appliqué nous obtenons les structures suivantes:

```{r iid_meso_plot, echo = FALSE, message=FALSE}
for (idx in seq_along(iid_unlist)) {
  cat(paste("\nPour la collection", idx, "du modèle *iid*\n"))
  print(plot(iid_unlist[[idx]], type = "meso", mixture = TRUE))
  print(iid_unlist[[idx]]$net_id)
}
```

Et voici donc les valeurs numériques pour les $\alpha$ (paramètres de connectivité).

```{r iid_alpha, echo = FALSE, results="asis"}
for (idx in seq_along(iid_unlist)) {
  cat(paste("\nPour la collection ", idx, ":\n"))
  cat(knitr::knit_print(reorder_parameters(iid_unlist[[idx]])$alpha))
}
```

### Répartition dans les clusters selon la taxonomie
```{r iid_taxonomy, echo = FALSE}
iid_taxonomy <- taxonomy_in_clusters(iid_unlist)

iid_taxonomy_long <- map_dfr(iid_taxonomy,
  function(collection) {
    map_dfr(
      c("insects", "plants"),
      function(group) {
        get_formatted_data(collection, group)
      }
    )
  },
  .id = "Collection"
)
```

```{r iid_plot_taxonomy_pollinators, echo = FALSE, message = FALSE,fig.cap = 'Pollinators repartition for the iid model regarding taxonomy'}
# Pollinators
taxonomy_plot(
  data = iid_taxonomy_long,
  insects_or_plants = "insects",
  stack_or_fill = "stack", model = "iid"
)
taxonomy_plot(
  data = iid_taxonomy_long,
  insects_or_plants = "insects",
  stack_or_fill = "fill", model = "iid"
)
```

```{r iid_plot_taxonomy_plants, echo = FALSE, message = FALSE,fig.cap = 'Plants repartition for the iid model regarding taxonomy'}
taxonomy_plot(
  data = iid_taxonomy_long,
  insects_or_plants = "plants",
  stack_or_fill = "stack", model = "iid"
)
taxonomy_plot(
  data = iid_taxonomy_long,
  insects_or_plants = "plants",
  stack_or_fill = "fill", model = "iid"
)
```

## Clustering avec le modèle pi
Avec le modèle *pi* nous obtenons les `r length(pi_unlist)` collections suivantes:
```{r pi_liste_nom, echo = FALSE, results="asis"}
pi_networks_list <- lapply(seq_along(pi_unlist), function(c) {
  length <- length(pi_unlist[[c]]$net_id)
  data.frame(collection_id = rep(c, length), net_id = pi_unlist[[c]]$net_id)
})
for (df_net in pi_networks_list) {
  print(knitr::kable(df_net))
}
```

Une fois le modèle de collection appliqué nous obtenons les structures suivantes:

```{r pi_meso_plot, echo = FALSE, message=FALSE}
for (idx in seq_along(pi_unlist)) {
  cat(paste("\nPour la collection", idx, "du modèle *pi*\n"))
  print(plot(pi_unlist[[idx]], type = "meso", mixture = TRUE))
  print(pi_unlist[[idx]]$net_id)
}
```

Et voici donc les valeurs numériques pour les $\alpha$ (paramètres de connectivité).

```{r pi_alpha, echo = FALSE, results="asis"}
for (idx in seq_along(pi_unlist)) {
  cat(paste("\nPour la collection ", idx, ":\n"))
  cat(knitr::knit_print(reorder_parameters(pi_unlist[[idx]])$alpha))
}
```

### Répartition dans les clusters selon la taxonomie
```{r pi_taxonomy, echo = FALSE}
pi_taxonomy <- taxonomy_in_clusters(pi_unlist)

pi_taxonomy_long <- map_dfr(pi_taxonomy,
  function(collection) {
    map_dfr(
      c("insects", "plants"),
      function(group) {
        get_formatted_data(collection, group)
      }
    )
  },
  .id = "Collection"
)
```

```{r pi_plot_taxonomy_pollinators, echo = FALSE, message = FALSE,fig.cap = 'Pollinators repartition for the pi model regarding taxonomy'}
# Pollinators
taxonomy_plot(
  data = pi_taxonomy_long,
  insects_or_plants = "insects",
  stack_or_fill = "stack", model = "pi"
)
taxonomy_plot(
  data = pi_taxonomy_long,
  insects_or_plants = "insects",
  stack_or_fill = "fill", model = "pi"
)
```

```{r pi_plot_taxonomy_plants, echo = FALSE, message = FALSE,fig.cap = 'Plants repartition for the pi model regarding taxonomy'}
taxonomy_plot(
  data = pi_taxonomy_long,
  insects_or_plants = "plants",
  stack_or_fill = "stack", model = "pi"
)
taxonomy_plot(
  data = pi_taxonomy_long,
  insects_or_plants = "plants",
  stack_or_fill = "fill", model = "pi"
)
```

## Clustering avec le modèle rho
Avec le modèle *rho* nous obtenons les `r length(rho_unlist)` collections suivantes:
```{r rho_liste_nom, echo = FALSE, results="asis"}
print(knitr::kable(rho_unlist$net_id))
```

Une fois le modèle de collection appliqué nous obtenons les structures suivantes:

```{r rho_meso_plot, echo = FALSE, message=FALSE}
cat(paste("\nPour la collection 1 du modèle *rho*\n"))
print(plot(rho_unlist, type = "meso", mixture = TRUE))
print(rho_unlist$net_id)
```

Et voici donc les valeurs numériques pour les $\alpha$ (paramètres de connectivité).

```{r rho_alpha, echo = FALSE, results="asis"}
cat(paste("\nPour la collection 1:\n"))
cat(knitr::knit_print(reorder_parameters(rho_unlist)$alpha))
```

### Répartition dans les clusters selon la taxonomie
```{r rho_taxonomy, echo = FALSE}
rho_taxonomy <- taxonomy_in_clusters(rho_unlist)

rho_taxonomy_long <- map_dfr(rho_taxonomy,
  function(collection) {
    map_dfr(
      c("insects", "plants"),
      function(group) {
        get_formatted_data(collection, group)
      }
    )
  },
  .id = "Collection"
)
```

```{r rho_plot_taxonomy_pollinators, echo = FALSE, message = FALSE,fig.cap = 'Pollinators repartition for the rho model regarding taxonomy'}
# Pollinators
taxonomy_plot(
  data = rho_taxonomy_long,
  insects_or_plants = "insects",
  stack_or_fill = "stack", model = "rho"
)
taxonomy_plot(
  data = rho_taxonomy_long,
  insects_or_plants = "insects",
  stack_or_fill = "fill", model = "rho"
)
```

```{r rho_plot_taxonomy_plants, echo = FALSE, message = FALSE,fig.cap = 'Plants repartition for the rho model regarding taxonomy'}
taxonomy_plot(
  data = rho_taxonomy_long,
  insects_or_plants = "plants",
  stack_or_fill = "stack", model = "rho"
)
taxonomy_plot(
  data = rho_taxonomy_long,
  insects_or_plants = "plants",
  stack_or_fill = "fill", model = "rho"
)
```

## Clustering avec le modèle pirho
Avec le modèle *pirho* nous obtenons les `r length(pirho_unlist)` collections suivantes:
```{r pirho_liste_nom, echo = FALSE, results="asis"}
pirho_networks_list <- lapply(seq_along(pirho_unlist), function(c) {
  length <- length(pirho_unlist[[c]]$net_id)
  data.frame(collection_id = rep(c, length), net_id = pirho_unlist[[c]]$net_id)
})
for (df_net in pirho_networks_list) {
  print(knitr::kable(df_net))
}
```

Une fois le modèle de collection appliqué nous obtenons les structures suivantes:

```{r pirho_meso_plot, echo = FALSE, message=FALSE}
for (idx in seq_along(pirho_unlist)) {
  cat(paste("\nPour la collection", idx, "du modèle *pirho*\n"))
  print(plot(pirho_unlist[[idx]], type = "meso", mixture = TRUE))
  print(pirho_unlist[[idx]]$net_id)
}
```

Et voici donc les valeurs numériques pour les $\alpha$ (paramètres de connectivité).

```{r pirho_alpha, echo = FALSE, results="asis"}
for (idx in seq_along(pirho_unlist)) {
  cat(paste("\nPour la collection ", idx, ":\n"))
  cat(knitr::knit_print(reorder_parameters(pirho_unlist[[idx]])$alpha))
}
```

### Répartition dans les clusters selon la taxonomie
```{r pirho_taxonomy, echo = FALSE}
pirho_taxonomy <- taxonomy_in_clusters(pirho_unlist)

pirho_taxonomy_long <- map_dfr(pirho_taxonomy,
  function(collection) {
    map_dfr(
      c("insects", "plants"),
      function(group) {
        get_formatted_data(collection, group)
      }
    )
  },
  .id = "Collection"
)
```

```{r pirho_plot_taxonomy_pollinators, echo = FALSE, message = FALSE,fig.cap = 'Pollinators repartition for the pirho model regarding taxonomy'}
# Pollinators
taxonomy_plot(
  data = pirho_taxonomy_long,
  insects_or_plants = "insects",
  stack_or_fill = "stack", model = "pirho"
)
taxonomy_plot(
  data = pirho_taxonomy_long,
  insects_or_plants = "insects",
  stack_or_fill = "fill", model = "pirho"
)
```

```{r pirho_plot_taxonomy_plants, echo = FALSE, message = FALSE,fig.cap = 'Plants repartition for the pirho model regarding taxonomy'}
taxonomy_plot(
  data = pirho_taxonomy_long,
  insects_or_plants = "plants",
  stack_or_fill = "stack", model = "pirho"
)
taxonomy_plot(
  data = pirho_taxonomy_long,
  insects_or_plants = "plants",
  stack_or_fill = "fill", model = "pirho"
)
```
