---
title: "Tutorial on plant pollinator data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial on plant pollinitor data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.fullwidth = TRUE,
  fig.width = 6,
  fig.height = 6
)
```

```{r setup}
library(colSBM)
library(patchwork)
library(parallel)
data("dorebipartite")
```

# Estimation with colSBM

We load a list of 15 plant-pollinator networks. They are binary undirected networks with different
number of plant and pollinator species. First, we are going to model jointly the `r names(dorebipartite)[7:10]` networks,
using the *iid-colBiSBM* model.


```{r results=FALSE, warning=FALSE}
set.seed(1234)
res_pp_iid <- estimate_colBiSBM(
  netlist = dorebipartite[7:10], # A list of networks
  colsbm_model = "iid", # The name of the model
  net_id = names(dorebipartite)[7:10], # Name of the networks
  nb_run = 1L, # Number of runs of the algorithm
  global_opts = list(
    verbosity = 1,
    plot_detail = 0,
    nb_cores = 2,
    backend = "parallel"
  )
)
```

We can look at how the variational bound and the model selection criteria evolve with the number of clusters.
Here, the BICL criterion selects Q = `r res_pp_iid$best_fit$Q` blocks.


```{r, fig.cap="State-space exploration"}
plot(res_pp_iid)
best_fit <- res_pp_iid$best_fit
```

# Results and analysis

Here are some useful fields to analyze the results.

```{r}
best_fit
```

We can retrieve:

* the estimation of the model parameters

```{r}
best_fit$parameters
```

* The block memberships:

```{r}
best_fit$memberships[[4]]$row
```

And their probabilities:

```{r}
best_fit$prob_memberships[[3]][[1]][1:10, 1]
```

* The prediction for each dyads in the networks, here for network number 3.

```{r}
best_fit$pred_dyads[[3]][1:10, 1]
```

We can also plot the networks individually:

```{r plot-block, fig.cap = "Networks after fitting the model and reordering the nodes and blocks"}
plot(res_pp_iid$best_fit, type = "block", net_id = 1) +
  plot(res_pp_iid$best_fit, type = "block", net_id = 2) +
  plot(res_pp_iid$best_fit, type = "block", net_id = 3) +
  plot(res_pp_iid$best_fit, type = "block", net_id = 4)
```

Or make different plots to exhibit the mesoscale structure:

```{r, fig.cap=c("Graphon type plot", "Mesoscale type plot")}
plot(res_pp_iid$best_fit, type = "graphon")
plot(res_pp_iid$best_fit, type = "meso", mixture = TRUE)
```

# Clustering of networks

Lets simulate some bipartite networks with a lower triangular structure.

```{r}
set.seed(1234)
alpha <- matrix(c(
  .05, .01, .01, .01,
  .3, .05, .01, .01,
  .5, .4, .05, .01,
  .1, .8, .1, .05
), 4, 4, byrow = TRUE)
pi <- c(.1, .2, .6, .1)
rho <- c(.1, .2, .6, .1)
sim_net <-
  generate_bipartite_collection(
    nr = 30,
    nc = 40,
    pi = pi,
    rho = rho,
    alpha = alpha,
    M = 3,
    model = "iid"
  )
```


```{r results=FALSE}
set.seed(1234)
net_clust <- clusterize_bipartite_networks(
  netlist = c(dorebipartite[7:10], sim_net), # A list of networks
  colsbm_model = "iid", # The name of the model
  net_id = c(names(dorebipartite)[7:10], "sim1", "sim2", "sim3"), # Name of the networks
  nb_run = 1L, # Number of runs of the algorithm
  global_opts = list(
    verbosity = 0,
    plot_details = 0,
    nb_cores = 2,
    backend = "parallel",
    Q1_max = 9,
    Q2_max = 9
  ) # Max number of clusters
)
```

```{r}
best_partition <- unlist(extract_best_bipartite_partition(net_clust))
```

We obtain a list of `r length(unlist(best_partition))` tested collections. The lists are nested and reflect the
sequential steps of clustering.
The extraction of the best partition below reveals that our 3 simulated networks
are considered as being part of the same collection and that the among the 4
plant-pollinator networks there exists a difference leading to 2 collections that
contains networks from the same authors.



The plot of the mesoscale structure of the whole collection is the following:

```{r, fig.cap="Whole collection graphon type plot"}
plot(net_clust[[1]])
```

but then we can compare the mesoscale structures of the 3 groups:

```{r plot-part, fig.width = 8, fig.cap="Best partition graphon type plots"}
wrap_plots(
  plot(best_partition[[1]], type = "graphon"),
  plot(best_partition[[2]], type = "graphon"),
  plot(best_partition[[3]], type = "graphon"),
  ncol = 2) +
  plot_annotation(tag_levels = "1")
```
