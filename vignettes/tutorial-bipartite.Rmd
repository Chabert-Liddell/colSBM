---
title: "Tutorial on plant pollinisator data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Tutorial on food webs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(colSBM)
library(patchwork)
data("dorebipartite")
```

# Estimation with colSBM

We load a list of 15 plant-pollinator networks. They are binary undirected networks with different
number of plant and pollinator species. First, we are going to model jointly the first $3$ networks,
using the pi-colBiSBM model.


```{r results=FALSE, warning=FALSE}
set.seed(1234)
res_pp_pi <- estimate_colBiSBM(
  netlist = dorebipartite[1:3], # A list of networks
  colsbm_model = "pi", # The name of the model
  net_id = names(dorebipartite)[1:3], # Name of the networks
  nb_run = 1L, # Number of runs of the algorithm
  global_opts = list(
    verbosity = 1,
    plot_detail = 0,
    nb_cores = parallel::detectCores() - 1
  )
)
```

We can look at how the variational bound and the model selection criteria evolve with the number of clusters.
Here, the BICL criterion selects Q = `r res_pp_pi$best_fit$Q` blocks.


```{r}
plot(res_pp_pi)
best_fit <- res_pp_pi$best_fit
```

# Results and analysis

Here are some useful fields to analyze the results.

```{r}
best_fit
```

We can get:

* the estimation of the model parameters

```{r}
best_fit$parameters
```

* The block memberships:

```{r}
best_fit$pred_blockmemberships
```


* The prediction for each dyads in the networks, here for network number 3.

```{r}
best_fit$pred_dyads[[3]][1:10, 1:5]
```

We can also plot the networks individually:

```{r plot-block}
plot(res_pp_pi$best_fit, type = "block", net_id = 1) +
  plot(res_pp_pi$best_fit, type = "block", net_id = 2) +
  plot(res_pp_pi$best_fit, type = "block", net_id = 3)
```

Or make different plots to exhibit the mesoscale structure:

```{r}
plot(res_pp_pi$best_fit, type = "graphon")
plot(res_pp_pi$best_fit, type = "meso", mixture = TRUE)
```

# Clustering of networks

Let simulate some directed networks with a lower triangular structure that looks
alike foodwebs.

```{r}
set.seed(1234)
alpha <- matrix(c(
  .05, .01, .01, .01,
  .3, .05, .01, .01,
  .5, .4, .05, .01,
  .1, .8, .1, .05
), 4, 4, byrow = TRUE)
pi <- c(.1, .2, .6, .1)
rho <- c(.1, .2, .6, .1)
sim_net <-
  generate_bipartite_collection(
    nr = 30,
    nc = 40,
    pi = pi,
    rho = rho,
    alpha = alpha,
    M = 3,
    model = "pi"
  )
```


```{r results=FALSE}
set.seed(1234)
net_clust <- clusterize_bipartite_networks(
  netlist = c(dorebipartite[2:3], sim_net), # A list of networks
  colsbm_model = "pi", # The name of the model
  net_id = c(names(dorebipartite)[2:3], "sim1", "sim2", "sim3"), # Name of the networks
  nb_run = 1L, # Nmber of runs of the algorithm
  global_opts = list(
    verbosity = 0,
    plot_details = 0,
    nb_cores = parallel::detectCores() - 1,
    Q1_max = 9,
    Q2_max = 9
  ) # Max number of clusters
)
```


We obtain a list of 5 tested collections. The lists are nested and reflect the
sequential steps of clustering.
The extraction of the best partition below reveals that our 3 simulated networks
are considered as being part of the same collection and that the among the 3
plant-pollinator there exists a difference leading to 3 collections.

```{r}
best_partition <- extract_best_bipartite_partition(net_clust)
```

The plot of the mesoscale structure of the whole collection is the following:

```{r}
plot(net_clust[[1]])
```

but then we can compare the mesoscale structures of the 2 groups:

```{r plot-part}
plot(best_partition[[1]][[1]],
  type = "graphon"
) +
  plot(best_partition[[1]][[2]],
    type = "graphon"
  ) +
  plot(best_partition[[2]],
    type = "meso"
  ) +
  plot_layout(guides = "collect") + plot_annotation(tag_levels = "1")
```
