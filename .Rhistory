best_mod(l[[3]])))
}
res
best_mod(res)
best_mod(res)
binary_list <- function(l) {
#browser()
if(length(l) == 1)  return(l)
# if (length(l) == 2) return(list(l[1],
#                                 binary_list(l[2])))
s <- l[runif(length(l)) > .5]
if(runif(1) < .1) {
return (l)
} else {
return(list(l,
#list(
binary_list(s),
binary_list(setdiff(l, s))))#)
}
}
res <- binary_list(seq(7))
best_mod(res)
res <- binary_list(seq(15))
best_mod(res)
res
res <- binary_list(seq(15))
res <- binary_list(seq(15))
binary_list <- function(l) {
browser()
if(length(l) == 1)  return(l)
# if (length(l) == 2) return(list(l[1],
#                                 binary_list(l[2])))
s <- l[runif(length(l)) > .5]
if(runif(1) < .1) {
return (l)
} else {
return(list(l,
#list(
binary_list(s),
binary_list(setdiff(l, s))))#)
}
}
res <- binary_list(seq(15))
res
best_mod(res)
length(l)
length(res)
binary_list <- function(l) {
browser()
if(length(l) == 1)  return(l)
# if (length(l) == 2) return(list(l[1],
#                                 binary_list(l[2])))
s <- l[runif(length(l)) > .5]
if(runif(1) < .1) {
return (list(l))
} else {
return(list(l,
#list(
binary_list(s),
binary_list(setdiff(l, s))))#)
}
}
best_mod <- function(l) {
if(length(l) == 1)  return(l[[1]])
if(length(l) == 2) return(l[[2]])
return(list(best_mod(l[[2]]),
best_mod(l[[3]])))
}
res <- binary_list(seq(15))
floor(-.2)
binary_list <- function(l) {
browser()
if(length(l) == 1)  return(l)
# if (length(l) == 2) return(list(l[1],
#                                 binary_list(l[2])))
n <- 1 + floor(runif(1, 0, length(l) - 1))
s <- sample(length(l), n)
d <- setdiff(l,s)
#    l[runif(length(l)) > .5]
if(runif(1) < .1) {
return (list(l))
} else {
return(list(l,
#list(
binary_list(s),
binary_list(d)))#)
}
}
best_mod <- function(l) {
if(length(l) == 1)  return(l[[1]])
if(length(l) == 2) return(l[[2]])
return(list(best_mod(l[[2]]),
best_mod(l[[3]])))
}
res <- binary_list(seq(15))
res
best_mod(res)
binary_list <- function(l) {
#  browser()
if(length(l) == 1)  return(l)
# if (length(l) == 2) return(list(l[1],
#                                 binary_list(l[2])))
n <- 1 + floor(runif(1, 0, length(l) - 1))
s <- sample(length(l), n)
d <- setdiff(l,s)
#    l[runif(length(l)) > .5]
if(runif(1) < .1) {
return (list(l))
} else {
return(list(l,
#list(
binary_list(s),
binary_list(d)))#)
}
}
best_mod <- function(l) {
if(length(l) == 1)  return(l[[1]])
if(length(l) == 2) return(l[[2]])
return(list(best_mod(l[[2]]),
best_mod(l[[3]])))
}
res <- binary_list(seq(15))
res
best_mod(res)
res <- binary_list(seq(5))
res
binary_list <- function(l) {
#  browser()
if(length(l) == 1)  return(l)
# if (length(l) == 2) return(list(l[1],
#                                 binary_list(l[2])))
n <- 1 + floor(runif(1, 0, length(l) - 1))
s <- sample(l, n)
d <- setdiff(l,s)
#    l[runif(length(l)) > .5]
if(runif(1) < .1) {
return (list(l))
} else {
return(list(l,
#list(
binary_list(s),
binary_list(d)))#)
}
}
best_mod <- function(l) {
if(length(l) == 1)  return(l[[1]])
if(length(l) == 2) return(l[[2]])
return(list(best_mod(l[[2]]),
best_mod(l[[3]])))
}
res <- binary_list(seq(5))
best_mod(res)
res
res <- binary_list(seq(5))
res
best_mod(res)
res <- binary_list(seq(11))
best_mod(res)
res <- binary_list(seq(11))
best_mod(res)
res <- binary_list(seq(14))
best_mod(res)
res <- binary_list(seq(14))
best_mod(res)
b <- best_mod(res)
b
unlist(b)
res <- binary_list(seq(14))
b <- best_mod(res)
b
binary_list <- function(l) {
#  browser()
if(length(l) == 1)  return(l)
# if (length(l) == 2) return(list(l[1],
#                                 binary_list(l[2])))
n <- 1 + floor(runif(1, 0, length(l) - 1))
s <- sample(l, n)
d <- setdiff(l,s)
#    l[runif(length(l)) > .5]
if(runif(1) < .2) {
return (list(l))
} else {
return(list(l,
#list(
binary_list(s),
binary_list(d)))#)
}
}
best_mod <- function(l) {
if(length(l) == 1)  return(l[[1]])
if(length(l) == 2) return(l[[2]])
return(list(best_mod(l[[2]]),
best_mod(l[[3]])))
}
res <- binary_list(seq(14))
b <- best_mod(res)
b
binary_list <- function(l) {
#  browser()
if(length(l) == 1)  return(l)
# if (length(l) == 2) return(list(l[1],
#                                 binary_list(l[2])))
n <- 1 + floor(runif(1, 0, length(l) - 1))
s <- sample(l, n)
d <- setdiff(l,s)
#    l[runif(length(l)) > .5]
if(runif(1) < .3) {
return (list(l))
} else {
return(list(l,
#list(
binary_list(s),
binary_list(d)))#)
}
}
best_mod <- function(l) {
if(length(l) == 1)  return(l[[1]])
if(length(l) == 2) return(l[[2]])
return(list(best_mod(l[[2]]),
best_mod(l[[3]])))
}
res <- binary_list(seq(14))
b <- best_mod(res)
b
res <- binary_list(seq(14))
b <- best_mod(res)
b
unlist(b)
res <- binary_list(seq(14))
b <- best_mod(res)
b
unlist(b)
res
b
res <- binary_list(seq(14))
b <- best_mod(res)
b
res <- binary_list(seq(14))
b <- best_mod(res)
b
res
library(colSBM)
# Chunk 1
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# Chunk 2: setup
library(colSBM)
library(patchwork)
data("foodwebs")
# Chunk 3
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 2, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 3L,
global_opts = global_opts)
# Chunk 4
res_fw_iid$ICL_clustering
vapply(res_fw_iid$model_list[[1]], function(x) x[[1]]$vbound, .1)
vapply(res_fw_iid$model_list[[1]], function(x) rev(x[[1]]$vbound)[1], .1)
res_fw_iid$model_list[[1]]
res_fw_iid$model_list[[1]][[2]]
res_fw_iid$model_list[[1]][[2]][[1]]
res_fw_iid$model_list[[1]][[2]][[1]]$vbound
rev(res_fw_iid$model_list[[1]][[2]][[1]]$vbound)[1]
rev(res_fw_iid$model_list[[1]][[3]][[1]]$vbound)[1]
rev(res_fw_iid$model_list[[1]][[8]][[1]]$vbound)[1]
rev(res_fw_iid$model_list[[1]][[8]][[1]]$vbound)[1]
vapply(res_fw_iid$model_list[[1]], function(x) rev(x[[1]]$vbound)[1], .1)
vapply(res_fw_iid$model_list[[1]], function(x) rev(x[[1]]$vbound)[1], .1)
rev(res_fw_iid$model_list[[1]][[8]][[1]]$vbound)[1]
lapply(res_fw_iid$model_list[[1]], function(x) rev(x[[1]]$vbound)[1])
res_fw_iid$model_list[[1]][[1]][[1]]$vbound
library(colSBM)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 3L,
global_opts = global_opts)
vapply(res_fw_iid$model_list[[1]], function(x) rev(x[[1]]$vbound)[1], .1)
res_fw_iid$model_list[[1]][[1]][[1]]$vbound
res_fw_iid$model_list[[1]][[1]][[1]]$ICL
library(colSBM)
microbenchmark::microbenchmark(Matrix::Matrix(data = foodwebs[[1]]))
library(colSBM)
# Chunk 1
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# Chunk 2: setup
library(colSBM)
library(patchwork)
data("foodwebs")
# Chunk 3
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 2, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 3L,
global_opts = global_opts)
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 1, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
library(colSBM)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 3L,
global_opts = global_opts)
library(colSBM)
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 1, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 1L,
global_opts = global_opts)
library(colSBM)
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 1, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 1L,
global_opts = global_opts)
library(colSBM)
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 1, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 1L,
global_opts = global_opts)
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 1, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 1L,
global_opts = global_opts)
library(colSBM)
library(colSBM)
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 1, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 1L,
global_opts = global_opts)
res_fw_iid$ICL_sbm
res_fw_iid$ICL_sbm
res_fw_iid$fit_sbm
which.max(res_fw_iid$fit_sbm[[1]]()
which.max(res_fw_iid$fit_sbm[[1]])
sapply(seq(res_fw_iid$M), function(m) max(res_fw_iid$fit_sbm[[m]]$ICL))
sum(sapply(seq(res_fw_iid$M), function(m) max(res_fw_iid$fit_sbm[[m]]$ICL)))
sum(sapply(seq(res_fw_iid$M), function(m) max(res_fw_iid$fit_sbm[[m]]$loglik)))
sum(sapply(seq(res_fw_iid$M), function(m) max(res_fw_iid$fit_sbm[[m]]$loglik-res_fw_iid$fit_sbm[[m]]$penalty)))
sum(sapply(seq(res_fw_iid$M), function(m) max(res_fw_iid$fit_sbm[[m]]$loglik+res_fw_iid$fit_sbm[[m]]$entropy)))
sapply(seq(res_fw_iid$M), function(m) max(res_fw_iid$fit_sbm[[m]]$loglik+res_fw_iid$fit_sbm[[m]]$entropy))
res_fw_iid$fit_sbm[[1]]$loglik
res_fw_iid$fit_sbm[[1]]
res_fw_iid$fit_sbm[[1]]$ICL
res_fw_iid$fit_sbm[[1]]$storedModels
res_fw_iid$fit_sbm[[1]]$storedModels$ICL
max(res_fw_iid$fit_sbm[[1]]$storedModels$ICL)
res_fw_iid$fit_sbm[[1]]$penalty
627.6722 + 965.1618
627.6722/2 + 965.1618
res_fw_iid$fit_sbm[[1]]$entropy
res_fw_iid$fit_sbm[[1]]$loglik
res_fw_iid$fit_sbm[[1]]$loglik + res_fw_iid$fit_sbm[[1]]$entropy
sum(sapply(seq(res_fw_iid$M), function(m) max(res_fw_iid$fit_sbm[[m]]$storedModels$ICL)))
sapply(seq(res_fw_iid$M), function(m) max(res_fw_iid$fit_sbm[[m]]$storedModels$ICL))
library(colSBM)
global_opts = list(nb_cores = 1L,
nb_models = 5L,
nb_init = 10L,
depth = 2L,
verbosity = 1, spectral_init = FALSE,
Q_max = 8L, plot_details = 1)
set.seed(1234)
res_fw_iid <- estimate_colSBM(netlist = foodwebs[1:3],
colsbm_model = "iid",
directed = TRUE,
net_id = names(foodwebs)[1:3],
nb_run = 1L,
global_opts = global_opts)
install.packages("lobstr")
lobstr::obj_size(res_fw_iid)
lobstr::obj_sizes(res_fw_iid)
res_fw_iid
lobstr::obj_sizes(res_fw_iid)
usethis::use_readme_rmd()
usethis::use_citation()
pkgdown
pkgdown::build_site()
pkgdown::build_home()
pkgdown::build_home()
pkgdown::build_site()
pkgdown::build_articles()
pkgdown::build_articles()
library(colSBM)
pkgdown::build_articles()
library(colSBM)
pkgdown::build_home()
pkgdown::build_home_index()
library(colSBM)
pkgdown::build_home()
library(colSBM)
devtools::document()
use_package("cluster")
library(devtools)
library(usethis)
use_package("cluster")
library(colSBM)
pkgdown::build_site()
library(colSBM)
devtools::document()
library(colSBM)
devtools::document()
devtools::document()
library(colSBM)
devtools::document()
library(colSBM)
use_version(which = "minor")
usethis::use_news_md()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
usethis::use_lifecycle_badge("experimental")
badger
install.packages("badger")
badger::badge_devel()
badger::badge_devel(pkg = "colSBM")
badger::badge_devel(pkg = "colSBM", colr = "green")
badger::badge_devel(pkg = "colSBM", color = "green")
badger::badge_last_commit()
badger::badge_last_commit(branch = "main")
badger::badge_last_commit(ref = "Chabert-Liddell/colSBM", branch = "main")
badger::badge_doi(doi = "10.48550/arXiv.2206.00560", color = "mustard")
colourpicker:::colourPickerAddin()
named_list()
colourpicker:::colourPickerAddin()
badger::badge_doi(doi = "10.48550/arXiv.2206.00560", color = "blue")
badger::badge_doi(doi = "10.48550/arXiv.2206.00560", color = "yellow")
pkgdown::build_home()
pkgdown::build_home()
pkgdown::build_home()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_home()
