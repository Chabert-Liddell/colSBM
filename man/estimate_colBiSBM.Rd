% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/user-function.R
\name{estimate_colBiSBM}
\alias{estimate_colBiSBM}
\title{Estimate a colBiSBM on a collection of networks}
\usage{
estimate_colBiSBM(
  netlist,
  colsbm_model,
  net_id = NULL,
  distribution = "bernoulli",
  nb_run = 3L,
  global_opts = list(),
  fit_opts = list(),
  Z_init = NULL,
  silent_parallelization = FALSE
)
}
\arguments{
\item{netlist}{A list of matrices.}

\item{colsbm_model}{Which colBiSBM to use, one of "iid", "pi", "rho",
"pirho".}

\item{net_id}{A vector of string, the name of the networks.}

\item{distribution}{A string, the emission distribution, either "bernoulli"
(the default) or "poisson" (to be implemented)}

\item{nb_run}{An integer, the number of run the algorithm do. Default to 3.}

\item{global_opts}{Global options for the outer algorithm and the output.
See details.}

\item{fit_opts}{Fit options for the VEM algorithm. See details}

\item{Z_init}{An optional bi-dimensional list of size Q1_max x Q2_max containing
for each value a list of two vectors of clusters memberships. Default to
NULL.}
}
\value{
A bisbmpop object listing a collection of models for the collection.
of networks
}
\description{
Estimate a colBiSBM on a collection of networks
}
\details{

}
\examples{
alpha1 <- matrix(c(0.8,0.1,0.2,0.7), byrow = TRUE, nrow = 2)
alpha2 <- matrix(c(0.8,0.5,0.5,0.2), byrow = TRUE, nrow = 2)
first_collection <- generate_bipartite_collection(nr = 50, nc = 25, pi = c(0.5,0.5), rho = c(0.5,0.5), alpha = alpha1, M = 2)
second_collection <- generate_bipartite_collection(nr = 50, nc = 25, pi = c(0.5,0.5), rho = c(0.5,0.5), alpha = alpha2, M = 2)

netlist <- append(first_collection, second_collection)

\dontrun{
# A collection where joint modelisation makes sense
cl_joint <- estimate_colBiSBM(
  netlist = first_collection, 
  colsbm_model = "iid", 
  global_opts = list(nb_cores = parallel::detectCores() - 1))
# A collection where joint modelisation doesn't make sense
cl_separated <- estimate_colBiSBM(
  netlist = netlist,
  colsbm_model = "iid",
  global_opts = list(nb_cores = parallel::detectCores() - 1))
}
}
\seealso{
\code{\link[=clusterize_bipartite_networks]{clusterize_bipartite_networks()}}, \code{\link[colSBM]{bisbmpop}},
\code{\link[colSBM]{fitBipartiteSBMPop}}, \code{browseVignettes("colSBM")}
}
