% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/user-function.R
\name{estimate_colBiSBM}
\alias{estimate_colBiSBM}
\title{Estimate a colBiSBM on a collection of networks}
\usage{
estimate_colBiSBM(
  netlist,
  colsbm_model,
  net_id = NULL,
  distribution = "bernoulli",
  nb_run = 3L,
  global_opts = list(),
  fit_opts = list(),
  fit_init = NULL,
  Z_init = NULL
)
}
\arguments{
\item{netlist}{A list of matrices.}

\item{colsbm_model}{Which colBiSBM to use, one of "iid", "pi", "rho",
"pirho", "deltapi".}

\item{net_id}{A vector of string, the name of the networks.}

\item{distribution}{A string, the emission distribution, either "bernoulli"
(the default) or "poisson"}

\item{nb_run}{An integer, the number of run the algorithm do.}

\item{global_opts}{Global options for the outer algorithm and the output.
See details.}

\item{fit_opts}{Fit options for the VEM algorithm}

\item{fit_init}{Do not use!
Optional fit init from where initializing the algorithm.}

\item{Z_init}{A bi-dimensional list of size Q1_max x Q2_max containing
for each value a list of two vectors of clusters memberships. Default to
NULL.}
}
\value{
A bisbmpop object listing a collection of models for the collection.
of networks
}
\description{
Estimate a colBiSBM on a collection of networks
}
\details{
The list of parameters \code{global_opts} essentially tunes the
optimization process and the variational EM algorithm,
with the following parameters
\itemize{
\item{\code{nb_cores} }{integer for number of cores used for
parallelization. Default is 1}
\item{\code{verbosity} }{integer for verbosity (0, 1, 2, 3, 4). Default is 1.
0 will disable completely the output of the function.}
\item{\code{Q1_max} }{integer for the max size in row to explore. Default is
computed with the following formula:
\code{floor(log(sum(sapply(netlist, function(A) nrow(A)))) + 2)}}
\item{\code{Q2_max} }{integer for the max size in columns to explore. Default is
computed with the following formula:
\code{floor(log(sum(sapply(netlist, function(A) ncol(A)))) + 2)}}
\item{\code{nb_models} }{the number of models to keep for each values of Q1,Q2.
Default is 5.}
\item{\code{depth} }{specifies how large will the moving window be. Default is 1,
meaning the window will go from (Q1 - 1, Q2 - 1) to (Q1 + 1, Q2 + 1) and all
the values in the square defined.}
\item{\code{plot_details} }{integer to control the display of the exploration and
moving window process. Values are 0 or 1. Default is 1.}
\item{\code{max_pass} }{the maximum number of moving window passes that will be
executed. Default is 10.}
\item{\code{parallelization_vector}}{a boolean vector of size 2. Each
boolean specifies if the level should be parallelized. c(TRUE, TRUE) means
that :
\itemize{
\item{\link{1} : the \code{nb_run} models will be computed in parallel}
\item{\link{2} : the possible models during the state space exploration will be
computed in parallel. Default is c(TRUE, TRUE) which gives the best
performances.}
}
}
}
}
\examples{
# Trivial example with Gnp networks:
Net <- lapply(
  list(.7, .7, .2, .2),
  function(p) {
    A <- matrix(0, 15, 15)
    A[lower.tri(A)][sample(15 * 14 / 2, size = round(p * 15 * 14 / 2))] <- 1
    A <- A + t(A)
  }
)
\dontrun{
cl <- estimate_colSBM(Net,
  colsbm_model = "delta",
  distribution = "bernoulli",
  nb_run = 1
)
}
}
\seealso{
\code{\link[=clusterize_networks]{clusterize_networks()}}, \code{\link[colSBM]{bisbmpop}},
\code{\link[colSBM]{fitBipartiteSBMPop}}, \code{browseVignettes("colSBM")}
}
