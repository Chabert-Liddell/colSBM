% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimatepopbm.R
\name{clusterize_unipartite_networks}
\alias{clusterize_unipartite_networks}
\title{Partition of a collection of unipartite networks based on their common
mesoscale structures}
\usage{
clusterize_unipartite_networks(
  netlist,
  colsbm_model,
  directed = FALSE,
  net_id = NULL,
  distribution = "bernoulli",
  nb_run = 3L,
  global_opts = list(),
  fit_opts = list(),
  fit_init = NULL,
  full_inference = FALSE,
  verbose = TRUE,
  temp_save_path = tempfile(fileext = ".Rds")
)
}
\arguments{
\item{netlist}{A list of matrices.}

\item{colsbm_model}{Which colSBM to use, one of "iid", "pi", "delta", "deltapi",}

\item{net_id}{A vector of string, the name of the networks.}

\item{distribution}{A string, the emission distribution, either "bernoulli"
(the default) or "poisson"}

\item{nb_run}{An integer, the number of run the algorithm do.}

\item{global_opts}{Global options for the outer algorithm and the output}

\item{fit_opts}{Fit options for the VEM algorithm}

\item{fit_init}{Do not use!
Optional fit init from where initializing the algorithm.}

\item{full_inference}{The default "FALSE", the algorithm stop once splitting
groups of networks does not improve the BICL criterion. If "TRUE", then
continue to split groups until a trivial classification of one network per
group.}

\item{verbose}{A boolean, should the function be verbose or not. Default to
TRUE.}

\item{temp_save_path}{A string, the path where to save the temporary results.
Defaults to a temporary file.}
}
\value{
A list with two elements:
\item{partition}{A list of models giving the best partition.}
\item{cluster}{A vector of integers giving the cluster of each network.}
}
\description{
Partition of a collection of unipartite networks based on their common
mesoscale structures
}
\details{
This functions make call to \code{estimate_colSBM}.
}
\examples{
alpha1 <- matrix(c(0.8, 0.1, 0.2, 0.7), byrow = TRUE, nrow = 2)
alpha2 <- matrix(c(0.8, 0.5, 0.5, 0.2), byrow = TRUE, nrow = 2)
first_collection <- generate_unipartite_collection(
  n = 50
  pi = c(0.5, 0.5),
  alpha = alpha1, M = 2
)
second_collection <- generate_unipartite_collection(
  n = 50,
  pi = c(0.5, 0.5),
  alpha = alpha2, M = 2
)

netlist <- append(first_collection, second_collection)

\dontrun{
cl_separated <- clusterize_networks(
  netlist = netlist,
  colsbm_model = "iid"
)
}
}
\seealso{
\code{\link[=estimate_colSBM]{estimate_colSBM()}},
\code{\link[colSBM]{fitSimpleSBMPop}}, \code{browseVignettes("colSBM")}
}
