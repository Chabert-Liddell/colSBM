% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R6class-fitBipartiteSBMPop.R
\name{fitBipartiteSBMPop}
\alias{fitBipartiteSBMPop}
\title{An R6 Class object, a fitted population of netowrks sbm
once $optimize() is done}
\description{
An R6 Class object, a fitted population of netowrks sbm
once $optimize() is done

An R6 Class object, a fitted population of netowrks sbm
once $optimize() is done
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{n}}{A list with two dimensions, each of size M for the rows and cols}

\item{\code{M}}{Number of networks}

\item{\code{A}}{List of incidence Matrix of size \verb{n[[1]][m]xn[[2]][m]}}

\item{\code{mask}}{List of M masks, indicating NAs in the matrices. 1 for NA, 0 else}

\item{\code{nonNAs}}{List of M masks, indicating non NAs in the matrices. 1 - mask, so 0 for NA, 1 for non NA}

\item{\code{nb_inter}}{A vector of length M the number of unique non NA entries}

\item{\code{Q}}{Number of clusters, vectors of size2}

\item{\code{tau}}{List of size M of list of two variational parameters.
\verb{n[[1]][m]xQ} matrices and \verb{n[[2]][m]xQ} matrices}

\item{\code{alpha}}{Matrix of size QxQ, connection parameters}

\item{\code{pi}}{List of M vectors of size Q, the mixture parameters}

\item{\code{pim}}{List of M vectors of size Q, the mixture parameters in case
of free_mixture}

\item{\code{e}}{Vector of size M, the sum of unique entries}

\item{\code{emqr}}{List of M QxQ matrix, the sum of edges between q and r in m,
ie the edges that are observed.}

\item{\code{nmqr}}{list of M QxQ matrix, the number of entries between q and r
in m, ie all the possible edges.}

\item{\code{alpham}}{list of M QxQ matrix, the classic sbm parameters.}

\item{\code{free_mixture_row}}{A boolean indicating if there is a free mixture
on the rows}

\item{\code{free_mixture_col}}{A boolean indicating if there is a free mixture
on the columns}

\item{\code{weight}}{A vector of size M for weighted likelihood}

\item{\code{distribution}}{Emission distribution either : "poisson" or
"bernoulli"}

\item{\code{mloss}}{Loss on the M step of the VEM}

\item{\code{vloss}}{Loss on the VE step of the VEM}

\item{\code{vbound}}{The variational bound}

\item{\code{entropy}}{The entropy of the variational distribution}

\item{\code{net_id}}{A vector containing the "ids" or names of the networks
(if none given, they are set to their number in A list)}

\item{\code{df_mixture}}{The degrees of freedom for mixture parameters pi,used
to compute penalty}

\item{\code{df_connect}}{The degrees of freedom for connection parameters
alpha,used to compute penalty}

\item{\code{Cpi}}{A list of matrices of size Qd x M containing TRUE (1)
or FALSE (0) if the d-th dimension cluster is represented
in the network m}

\item{\code{Calpha}}{The corresponding support on the connectivity parameters
computed with Cpi.}

\item{\code{logfactA}}{A quantity used with the Poisson probability distribution}

\item{\code{init_method}}{The initialization method used for the first clustering}

\item{\code{penalty}}{The penalty computed based on the number of parameters}

\item{\code{Z}}{The clusters memberships, a list of size M of two matrices : 1
for rows clusters memberships and 2 for columns clusters memberships}

\item{\code{MAP}}{Maximum a posteriori}

\item{\code{MAP_parameters}}{MAP params}

\item{\code{ICL}}{Stores the ICL of the model}

\item{\code{BICL}}{Stores the BICL of the model}

\item{\code{fit_opts}}{Fit parameters, used to determine the fitting method/}

\item{\code{step_counter}}{Counts the number of passes}

\item{\code{greedy_exploration_starting_point}}{Stores the coordinates Q1 & Q2
from the greedy exploration to  keep track of the starting_point}

\item{\code{effective_clustering_list}}{A list of size M storing the number
of the clusters that contains at least one point. Used for safety checks.}

\item{\code{clustering_is_complete}}{A boolean used to know if the model real
blocks match the expected blocks.}

\item{\code{tested_taus}}{A vector of taus values for taus given by init_clust}

\item{\code{tested_taus_vbound}}{A vector of vbound values for taus given by init_clust}

\item{\code{has_converged}}{A boolean, indicating wether the current fit object
VEM converged or not}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{nb_nodes}}{Returns n a list of the number of nodes per network}

\item{\code{nb_blocks}}{Returns Q a vector with 2 coordinates, Q1 and Q2 for the
row blocks and the column blocks}

\item{\code{support}}{Returns the Cpi, a list of M boolean matrices indicating
which blocks are populated}

\item{\code{prob_memberships}}{Returns the tau, the probabilities of memberships
"a posteriori", after seeing the data}

\item{\code{parameters}}{Returns the list of parameters of the model, alpha, pi
and rho}

\item{\code{pred_dyads}}{Predicted dyads from the estimated probabilities and
parameters}

\item{\code{memberships}}{The block memberships}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-fitBipartiteSBMPop-new}{\code{fitBipartiteSBMPop$new()}}
\item \href{#method-fitBipartiteSBMPop-compute_MAP}{\code{fitBipartiteSBMPop$compute_MAP()}}
\item \href{#method-fitBipartiteSBMPop-vb_tau_alpha}{\code{fitBipartiteSBMPop$vb_tau_alpha()}}
\item \href{#method-fitBipartiteSBMPop-vb_tau_pi}{\code{fitBipartiteSBMPop$vb_tau_pi()}}
\item \href{#method-fitBipartiteSBMPop-entropy_tau}{\code{fitBipartiteSBMPop$entropy_tau()}}
\item \href{#method-fitBipartiteSBMPop-compute_vbound}{\code{fitBipartiteSBMPop$compute_vbound()}}
\item \href{#method-fitBipartiteSBMPop-compute_penalty}{\code{fitBipartiteSBMPop$compute_penalty()}}
\item \href{#method-fitBipartiteSBMPop-compute_icl}{\code{fitBipartiteSBMPop$compute_icl()}}
\item \href{#method-fitBipartiteSBMPop-compute_entropy}{\code{fitBipartiteSBMPop$compute_entropy()}}
\item \href{#method-fitBipartiteSBMPop-compute_BICL}{\code{fitBipartiteSBMPop$compute_BICL()}}
\item \href{#method-fitBipartiteSBMPop-update_MAP_parameters}{\code{fitBipartiteSBMPop$update_MAP_parameters()}}
\item \href{#method-fitBipartiteSBMPop-fixed_point_tau}{\code{fitBipartiteSBMPop$fixed_point_tau()}}
\item \href{#method-fitBipartiteSBMPop-update_pim}{\code{fitBipartiteSBMPop$update_pim()}}
\item \href{#method-fitBipartiteSBMPop-update_pi}{\code{fitBipartiteSBMPop$update_pi()}}
\item \href{#method-fitBipartiteSBMPop-update_alpham}{\code{fitBipartiteSBMPop$update_alpham()}}
\item \href{#method-fitBipartiteSBMPop-update_alpha}{\code{fitBipartiteSBMPop$update_alpha()}}
\item \href{#method-fitBipartiteSBMPop-taus_order}{\code{fitBipartiteSBMPop$taus_order()}}
\item \href{#method-fitBipartiteSBMPop-init_clust}{\code{fitBipartiteSBMPop$init_clust()}}
\item \href{#method-fitBipartiteSBMPop-m_step}{\code{fitBipartiteSBMPop$m_step()}}
\item \href{#method-fitBipartiteSBMPop-ve_step}{\code{fitBipartiteSBMPop$ve_step()}}
\item \href{#method-fitBipartiteSBMPop-update_mqr}{\code{fitBipartiteSBMPop$update_mqr()}}
\item \href{#method-fitBipartiteSBMPop-make_permutation}{\code{fitBipartiteSBMPop$make_permutation()}}
\item \href{#method-fitBipartiteSBMPop-compute_effective_clustering}{\code{fitBipartiteSBMPop$compute_effective_clustering()}}
\item \href{#method-fitBipartiteSBMPop-optimize}{\code{fitBipartiteSBMPop$optimize()}}
\item \href{#method-fitBipartiteSBMPop-reorder_parameters}{\code{fitBipartiteSBMPop$reorder_parameters()}}
\item \href{#method-fitBipartiteSBMPop-show}{\code{fitBipartiteSBMPop$show()}}
\item \href{#method-fitBipartiteSBMPop-print}{\code{fitBipartiteSBMPop$print()}}
\item \href{#method-fitBipartiteSBMPop-clone}{\code{fitBipartiteSBMPop$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-new"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-new}{}}}
\subsection{Method \code{new()}}{
Initializes the fitBipartiteSBMPop object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$new(
  A = NULL,
  Q = NULL,
  Z = NULL,
  mask = NULL,
  net_id = NULL,
  distribution = NULL,
  free_mixture_row = TRUE,
  free_mixture_col = TRUE,
  Cpi = NULL,
  Calpha = NULL,
  init_method = "spectral",
  weight = NULL,
  greedy_exploration_starting_point = NULL,
  fit_opts = list(algo_ve = "fp", minibatch = TRUE, verbosity = 1)
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{A}}{List of incidence Matrix of size \verb{n[[2]][m]xn[[2]][m]}}

\item{\code{Q}}{A vector of size 2 with the number of row blocks and column
blocks}

\item{\code{Z}}{The clusters memberships, a list of size M of two matrices : 1
for rows clusters memberships and 2 for columns clusters memberships}

\item{\code{mask}}{List of M masks, indicating NAs in the matrices. 1 for NA, 0 else}

\item{\code{net_id}}{A vector containing the "ids" or names of the networks
(if none given, they are set to their number in A list)}

\item{\code{distribution}}{Emission distribution either : "poisson" or
"bernoulli"}

\item{\code{free_mixture_row}}{A boolean indicating if there is a free mixture
on the rows}

\item{\code{free_mixture_col}}{A boolean indicating if there is a free mixture
on the columns}

\item{\code{Cpi}}{A list of matrices of size Qd x M containing TRUE (1)
or FALSE (0) if the d-th dimension cluster is represented
in the network m}

\item{\code{Calpha}}{The corresponding support on the connectivity parameters
computed with Cpi.}

\item{\code{init_method}}{The initialization method used for the first clustering}

\item{\code{weight}}{A vector of size M for weighted likelihood}

\item{\code{greedy_exploration_starting_point}}{Stores the coordinates Q1 & Q2
from the greedy exploration to  keep track of the starting_point}

\item{\code{fit_opts}}{Fit parameters, used to determine the fitting method/
Method to compute the maximum a posteriori for Z clustering}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_MAP"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_MAP}{}}}
\subsection{Method \code{compute_MAP()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_MAP()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; stores the values
Computes the portion of the vbound with tau and alpha
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-vb_tau_alpha"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-vb_tau_alpha}{}}}
\subsection{Method \code{vb_tau_alpha()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$vb_tau_alpha(m, MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The id of the network for which to compute}

\item{\code{MAP}}{Wether to use the MAP parameters or not, a boolean, defaults
to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The computed quantity.
Computes the portion of the vbound with tau pi and rho
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-vb_tau_pi"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-vb_tau_pi}{}}}
\subsection{Method \code{vb_tau_pi()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$vb_tau_pi(m, MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The id of the network for which to compute}

\item{\code{MAP}}{Wether to use the MAP parameters or not, a boolean, defaults
to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The computed quantity.
Computes the entropy of the model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-entropy_tau"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-entropy_tau}{}}}
\subsection{Method \code{entropy_tau()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$entropy_tau(m)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The id of the network for which to compute}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The computed quantity.
Computes the variational bound (vbound)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_vbound"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_vbound}{}}}
\subsection{Method \code{compute_vbound()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_vbound()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The variational bound for the model.
Computes the penalty for the model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_penalty"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_penalty}{}}}
\subsection{Method \code{compute_penalty()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_penalty(
  penalty_factor = self$fit_opts$penalty_factor
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{penalty_factor}}{The penalty factor, a numeric, defaults to
self$fit_opts$penalty_factor, which is 0.5 by default.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the computed penalty using the formulae.
Computes the ICL criterion
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_icl"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_icl}{}}}
\subsection{Method \code{compute_icl()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_icl(MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{Wether to use the MAP parameters or not, a boolean, defaults
to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The ICL for the model.
Computes the entropy of the variational distribution
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_entropy"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_entropy}{}}}
\subsection{Method \code{compute_entropy()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_entropy()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The entropy of the variational distribution computed during VEM
Computes the BICL criterion
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_BICL"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_BICL}{}}}
\subsection{Method \code{compute_BICL()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_BICL(
  MAP = TRUE,
  penalty_factor = self$fit_opts$penalty_factor,
  store = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{Wether to use the MAP parameters or not, a boolean, defaults
to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The BICL for the model.
Updates the MAP parameters
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_MAP_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_MAP_parameters}{}}}
\subsection{Method \code{update_MAP_parameters()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_MAP_parameters()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; but stores the values
Method to update tau values
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-fixed_point_tau"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-fixed_point_tau}{}}}
\subsection{Method \code{fixed_point_tau()}}{
Not really a fixed point as tau^1 depends only tau^2.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$fixed_point_tau(m, d, tol = self$fit_opts$tolerance)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist}

\item{\code{d}}{The dimension to update}

\item{\code{tol}}{The tolerance for which to stop iterating. Defaults to
self$fit_opts$tolerance}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The new tau values
Computes the pi per network, known as the pim
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_pim"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_pim}{}}}
\subsection{Method \code{update_pim()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_pim(m, MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist}

\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing; stores the values
Computes the pi for the whole model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_pi"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_pi}{}}}
\subsection{Method \code{update_pi()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_pi(MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the pi and stores the values
Computes the alpha per network, known as the alpham
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_alpham"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_alpham}{}}}
\subsection{Method \code{update_alpham()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_alpham(m, MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist}

\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the alpham and stores the values
Computes the alpha for the whole model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_alpha"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_alpha}{}}}
\subsection{Method \code{update_alpha()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_alpha(MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the alpha and stores the values
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-taus_order"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-taus_order}{}}}
\subsection{Method \code{taus_order()}}{
The goal of this function is to test different values of tau
and select the best one in the sense of the BICL (or vbound) ?
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$taus_order(taus_list)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{taus_list}}{List of possible taus for which to provide a ranking}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A vector with the order of the taus in regard of vbound
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-init_clust"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-init_clust}{}}}
\subsection{Method \code{init_clust()}}{
Initialize clusters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$init_clust()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; stores
The M step of the VEM
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-m_step"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-m_step}{}}}
\subsection{Method \code{m_step()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$m_step(MAP = FALSE, tol = self$fit_opts$tolerance, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}

\item{\code{tol}}{The tolerance for which to stop iterating defaults to
self$fit_opts$tolerance}

\item{\code{...}}{Other parameters}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing; stores values
An optimization version for the VE step of the VEM but currently a
placeholder
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-ve_step"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-ve_step}{}}}
\subsection{Method \code{ve_step()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$ve_step(m, max_iter = 2, tol = self$fit_opts$tolerance, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist}

\item{\code{max_iter}}{The maximum number of iterations, default to 2}

\item{\code{tol}}{The tolerance for which to stop iterating defaults to
self$fit_opts$tolerance}

\item{\code{...}}{Other parameters}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing; stores values
Updates the mqr quantities
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_mqr"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_mqr}{}}}
\subsection{Method \code{update_mqr()}}{
Namely, it updates the emqr and nmqr.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_mqr(m)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist
TODO Investigate what its supposed to do}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-make_permutation"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-make_permutation}{}}}
\subsection{Method \code{make_permutation()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$make_permutation()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing
Computes the number of blocks that are effectively populated
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_effective_clustering"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_effective_clustering}{}}}
\subsection{Method \code{compute_effective_clustering()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_effective_clustering()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; but stores the value
Perform the whole initialization and VEM algorithm
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-optimize"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-optimize}{}}}
\subsection{Method \code{optimize()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$optimize(
  max_step = self$fit_opts$max_vem_steps,
  tol = self$fit_opts$tolerance,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{max_step}}{The maximum number of steps to perform optimization}

\item{\code{tol}}{The tolerance for which to stop iterating, default to
self$fit_opts$tolerance}

\item{\code{...}}{Other parameters}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing
Reorder the blocks putting the "strongest" ones first in order to have
a coherent ordering of blocks with SBM and LBM for visualisation.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-reorder_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-reorder_parameters}{}}}
\subsection{Method \code{reorder_parameters()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$reorder_parameters()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; stores the new ordering
The message printed when one prints the object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-show"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-show}{}}}
\subsection{Method \code{show()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$show(type = "Fitted Collection of Bipartite SBM")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{The title above the message.
The print method}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-print"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-print}{}}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$print()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; print to console
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-clone"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
