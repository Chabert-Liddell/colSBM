% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R6class-fitBipartiteSBMPop.R
\name{fitBipartiteSBMPop}
\alias{fitBipartiteSBMPop}
\title{The method to plot the fitBipartite objects}
\description{
The method to plot the fitBipartite objects

The method to plot the fitBipartite objects
}
\details{
An R6 Class object, a fitted population of netowrks sbm
once $optimize() is done
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{n}}{A list with two dimensions, each of size M for the rows and cols}

\item{\code{M}}{Number of networks}

\item{\code{A}}{List of incidence Matrix of size \verb{n[[1]][m]xn[[2]][m]}}

\item{\code{mask}}{List of M masks, indicating NAs in the matrices. 1 for NA, 0 else}

\item{\code{nonNAs}}{List of M masks, indicating non NAs in the matrices. 1 - mask, so 0 for NA, 1 for non NA}

\item{\code{nb_inter}}{A vector of length M the number of unique non NA entries}

\item{\code{Q}}{Number of clusters, vectors of size2}

\item{\code{tau}}{List of size M of list of two variational parameters.
\verb{n[[1]][m]xQ} matrices and \verb{n[[2]][m]xQ} matrices}

\item{\code{alpha}}{Matrix of size QxQ, connection parameters}

\item{\code{pi}}{List of M vectors of size Q, the mixture parameters}

\item{\code{pim}}{List of M vectors of size Q, the mixture parameters in case
of free_mixture}

\item{\code{e}}{Vector of size M, the sum of unique entries}

\item{\code{emqr}}{List of M QxQ matrix, the sum of edges between q and r in m,
ie the edges that are observed.}

\item{\code{nmqr}}{list of M QxQ matrix, the number of entries between q and r
in m, ie all the possible edges.}

\item{\code{alpham}}{list of M QxQ matrix, the classic sbm parameters.}

\item{\code{free_mixture_row}}{A boolean indicating if there is a free mixture
on the rows}

\item{\code{free_mixture_col}}{A boolean indicating if there is a free mixture
on the columns}

\item{\code{weight}}{A vector of size M for weighted likelihood}

\item{\code{distribution}}{Emission distribution either : "poisson" or
"bernoulli"}

\item{\code{mloss}}{Loss on the M step of the VEM}

\item{\code{vloss}}{Loss on the VE step of the VEM}

\item{\code{vbound}}{The variational bound}

\item{\code{net_id}}{A vector containing the "ids" or names of the networks
(if none given, they are set to their number in A list)}

\item{\code{df_mixture}}{The degrees of freedom for mixture parameters pi,used
to compute penalty}

\item{\code{df_connect}}{The degrees of freedom for connection parameters
alpha,used to compute penalty}

\item{\code{Cpi}}{A list of matrices of size Qd x M containing TRUE (1)
or FALSE (0) if the d-th dimension cluster is represented
in the network m}

\item{\code{Calpha}}{The corresponding support on the connectivity parameters
computed with Cpi.}

\item{\code{logfactA}}{A quantity used with the Poisson probability distribution}

\item{\code{init_method}}{The initialization method used for the first clustering}

\item{\code{penalty}}{The penalty computed based on the number of parameters}

\item{\code{Z}}{The clusters memberships, a list of size M of two matrices : 1
for rows clusters memberships and 2 for columns clusters memberships}

\item{\code{MAP}}{Maximum a posteriori}

\item{\code{MAP_parameters}}{MAP params}

\item{\code{ICL}}{Stores the ICL of the model}

\item{\code{BICL}}{Stores the BICL of the model}

\item{\code{fit_opts}}{Fit parameters, used to determine the fitting method/}

\item{\code{step_counter}}{Counts the number of passes}

\item{\code{greedy_exploration_starting_point}}{Stores the coordinates Q1 & Q2
from the greedy exploration to  keep track of the starting_point}

\item{\code{effective_clustering_list}}{A list of size M storing the number
of the clusters that contains at least one point. Used for safety checks.}

\item{\code{clustering_is_complete}}{A boolean used to know if the model real
blocks match the expected blocks.}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{nb_nodes}}{Returns n a list of the number of nodes per network}

\item{\code{nb_blocks}}{Returns Q a vector with 2 coordinates, Q1 and Q2 for the
row blocks and the column blocks}

\item{\code{support}}{Returns the Cpi, a list of M boolean matrices indicating
which blocks are populated}

\item{\code{prob_memberships}}{Returns the tau, the probabilities of memberships
"a posteriori", after seeing the data}

\item{\code{parameters}}{Returns the list of parameters of the model, alpha, pi
and rho}

\item{\code{pred_dyads}}{Predicted dyads from the estimated probabilities and
parameters}

\item{\code{memberships}}{The block memberships}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-fitBipartiteSBMPop-new}{\code{fitBipartiteSBMPop$new()}}
\item \href{#method-fitBipartiteSBMPop-compute_MAP}{\code{fitBipartiteSBMPop$compute_MAP()}}
\item \href{#method-fitBipartiteSBMPop-vb_tau_alpha}{\code{fitBipartiteSBMPop$vb_tau_alpha()}}
\item \href{#method-fitBipartiteSBMPop-vb_tau_pi}{\code{fitBipartiteSBMPop$vb_tau_pi()}}
\item \href{#method-fitBipartiteSBMPop-entropy_tau}{\code{fitBipartiteSBMPop$entropy_tau()}}
\item \href{#method-fitBipartiteSBMPop-compute_vbound}{\code{fitBipartiteSBMPop$compute_vbound()}}
\item \href{#method-fitBipartiteSBMPop-compute_penalty}{\code{fitBipartiteSBMPop$compute_penalty()}}
\item \href{#method-fitBipartiteSBMPop-compute_icl}{\code{fitBipartiteSBMPop$compute_icl()}}
\item \href{#method-fitBipartiteSBMPop-compute_BICL}{\code{fitBipartiteSBMPop$compute_BICL()}}
\item \href{#method-fitBipartiteSBMPop-update_MAP_parameters}{\code{fitBipartiteSBMPop$update_MAP_parameters()}}
\item \href{#method-fitBipartiteSBMPop-fixed_point_tau}{\code{fitBipartiteSBMPop$fixed_point_tau()}}
\item \href{#method-fitBipartiteSBMPop-update_pim}{\code{fitBipartiteSBMPop$update_pim()}}
\item \href{#method-fitBipartiteSBMPop-update_pi}{\code{fitBipartiteSBMPop$update_pi()}}
\item \href{#method-fitBipartiteSBMPop-update_alpham}{\code{fitBipartiteSBMPop$update_alpham()}}
\item \href{#method-fitBipartiteSBMPop-update_alpha}{\code{fitBipartiteSBMPop$update_alpha()}}
\item \href{#method-fitBipartiteSBMPop-init_clust}{\code{fitBipartiteSBMPop$init_clust()}}
\item \href{#method-fitBipartiteSBMPop-m_step}{\code{fitBipartiteSBMPop$m_step()}}
\item \href{#method-fitBipartiteSBMPop-ve_step}{\code{fitBipartiteSBMPop$ve_step()}}
\item \href{#method-fitBipartiteSBMPop-update_mqr}{\code{fitBipartiteSBMPop$update_mqr()}}
\item \href{#method-fitBipartiteSBMPop-make_permutation}{\code{fitBipartiteSBMPop$make_permutation()}}
\item \href{#method-fitBipartiteSBMPop-compute_effective_clustering}{\code{fitBipartiteSBMPop$compute_effective_clustering()}}
\item \href{#method-fitBipartiteSBMPop-optimize}{\code{fitBipartiteSBMPop$optimize()}}
\item \href{#method-fitBipartiteSBMPop-reorder_parameters}{\code{fitBipartiteSBMPop$reorder_parameters()}}
\item \href{#method-fitBipartiteSBMPop-show}{\code{fitBipartiteSBMPop$show()}}
\item \href{#method-fitBipartiteSBMPop-print}{\code{fitBipartiteSBMPop$print()}}
\item \href{#method-fitBipartiteSBMPop-plot}{\code{fitBipartiteSBMPop$plot()}}
\item \href{#method-fitBipartiteSBMPop-clone}{\code{fitBipartiteSBMPop$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-new"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-new}{}}}
\subsection{Method \code{new()}}{
Initializes the fitBipartiteSBMPop object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$new(
  A = NULL,
  Q = NULL,
  Z = NULL,
  mask = NULL,
  net_id = NULL,
  distribution = NULL,
  free_mixture_row = TRUE,
  free_mixture_col = TRUE,
  Cpi = NULL,
  Calpha = NULL,
  init_method = "spectral",
  weight = NULL,
  greedy_exploration_starting_point = NULL,
  fit_opts = list(algo_ve = "fp", approx_pois = TRUE, minibatch = TRUE, verbosity = 1)
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{A}}{List of incidence Matrix of size \verb{n[[2]][m]xn[[2]][m]}}

\item{\code{Q}}{A vector of size 2 with the number of row blocks and column
blocks}

\item{\code{Z}}{The clusters memberships, a list of size M of two matrices : 1
for rows clusters memberships and 2 for columns clusters memberships}

\item{\code{mask}}{List of M masks, indicating NAs in the matrices. 1 for NA, 0 else}

\item{\code{net_id}}{A vector containing the "ids" or names of the networks
(if none given, they are set to their number in A list)}

\item{\code{distribution}}{Emission distribution either : "poisson" or
"bernoulli"}

\item{\code{free_mixture_row}}{A boolean indicating if there is a free mixture
on the rows}

\item{\code{free_mixture_col}}{A boolean indicating if there is a free mixture
on the columns}

\item{\code{Cpi}}{A list of matrices of size Qd x M containing TRUE (1)
or FALSE (0) if the d-th dimension cluster is represented
in the network m}

\item{\code{Calpha}}{The corresponding support on the connectivity parameters
computed with Cpi.}

\item{\code{init_method}}{The initialization method used for the first clustering}

\item{\code{weight}}{A vector of size M for weighted likelihood}

\item{\code{greedy_exploration_starting_point}}{Stores the coordinates Q1 & Q2
from the greedy exploration to  keep track of the starting_point}

\item{\code{fit_opts}}{Fit parameters, used to determine the fitting method/
Method to compute the maximum a posteriori for Z clustering}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_MAP"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_MAP}{}}}
\subsection{Method \code{compute_MAP()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_MAP()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; stores the values
Computes the portion of the vbound with tau and alpha
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-vb_tau_alpha"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-vb_tau_alpha}{}}}
\subsection{Method \code{vb_tau_alpha()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$vb_tau_alpha(m, MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The id of the network for which to compute}

\item{\code{MAP}}{Wether to use the MAP parameters or not, a boolean, defaults
to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The computed quantity.
Computes the portion of the vbound with tau pi and rho
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-vb_tau_pi"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-vb_tau_pi}{}}}
\subsection{Method \code{vb_tau_pi()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$vb_tau_pi(m, MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The id of the network for which to compute}

\item{\code{MAP}}{Wether to use the MAP parameters or not, a boolean, defaults
to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The computed quantity.
Computes the entropy of the model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-entropy_tau"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-entropy_tau}{}}}
\subsection{Method \code{entropy_tau()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$entropy_tau(m)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The id of the network for which to compute}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The computed quantity.
Computes the variational bound (vbound)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_vbound"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_vbound}{}}}
\subsection{Method \code{compute_vbound()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_vbound()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The variational bound for the model.
Computes the penalty for the model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_penalty"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_penalty}{}}}
\subsection{Method \code{compute_penalty()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_penalty()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
the computed penalty using the formulae.
Computes the ICL criterion
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_icl"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_icl}{}}}
\subsection{Method \code{compute_icl()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_icl(MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{Wether to use the MAP parameters or not, a boolean, defaults
to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The ICL for the model.
Computes the BICL criterion
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_BICL"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_BICL}{}}}
\subsection{Method \code{compute_BICL()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_BICL(MAP = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{Wether to use the MAP parameters or not, a boolean, defaults
to FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The BICL for the model.
Updates the MAP parameters
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_MAP_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_MAP_parameters}{}}}
\subsection{Method \code{update_MAP_parameters()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_MAP_parameters()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; but stores the values
Method to update tau values
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-fixed_point_tau"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-fixed_point_tau}{}}}
\subsection{Method \code{fixed_point_tau()}}{
Not really a fixed point as tau^1 depends only tau^2.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$fixed_point_tau(m, d, max_iter = 1, tol = 0.001)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist}

\item{\code{d}}{The dimension to update}

\item{\code{max_iter}}{The maximum number of iterations to perform, defaults
to 1}

\item{\code{tol}}{The tolerance for which to stop iterating}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The new tau values
Computes the pi per network, known as the pim
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_pim"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_pim}{}}}
\subsection{Method \code{update_pim()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_pim(m, MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist}

\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing; stores the values
Computes the pi for the whole model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_pi"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_pi}{}}}
\subsection{Method \code{update_pi()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_pi(MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the pi and stores the values
Computes the alpha per network, known as the alpĥam
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_alpham"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_alpham}{}}}
\subsection{Method \code{update_alpham()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_alpham(m, MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist}

\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the alpham and stores the values
Computes the alpha for the whole model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_alpha"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_alpha}{}}}
\subsection{Method \code{update_alpha()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_alpha(MAP = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the alpha and stores the values
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-init_clust"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-init_clust}{}}}
\subsection{Method \code{init_clust()}}{
Initialize clusters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$init_clust()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; stores
The M step of the VEM
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-m_step"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-m_step}{}}}
\subsection{Method \code{m_step()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$m_step(MAP = FALSE, max_iter = 2, tol = 0.001, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{MAP}}{A boolean wether to use the MAP parameters or not, defaults to
FALSE}

\item{\code{max_iter}}{The maximum number of iterations, default to 2}

\item{\code{tol}}{The tolerance for which to stop iterating defaults to 1e-3}

\item{\code{...}}{Other parameters}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing; stores values
An optimization version for the VE step of the VEM but currently a
placeholder
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-ve_step"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-ve_step}{}}}
\subsection{Method \code{ve_step()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$ve_step(m, max_iter = 2, tol = 0.001, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist}

\item{\code{max_iter}}{The maximum number of iterations, default to 2}

\item{\code{tol}}{The tolerance for which to stop iterating defaults to 1e-3}

\item{\code{...}}{Other parameters}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing; stores values
Updates the mqr quantities
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-update_mqr"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-update_mqr}{}}}
\subsection{Method \code{update_mqr()}}{
Namely, it updates the emqr and nmqr.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$update_mqr(m)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{m}}{The number of the network in the netlist
TODO Investigate what its supposed to do}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-make_permutation"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-make_permutation}{}}}
\subsection{Method \code{make_permutation()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$make_permutation()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing
Computes the number of blocks that are effectively populated
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-compute_effective_clustering"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-compute_effective_clustering}{}}}
\subsection{Method \code{compute_effective_clustering()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$compute_effective_clustering()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; but stores the value
Perform the whole initialization and VEM algorithm
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-optimize"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-optimize}{}}}
\subsection{Method \code{optimize()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$optimize(max_step = 20, tol = 0.001, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{max_step}}{The maximum number of steps to perform optimization}

\item{\code{tol}}{The tolerance for which to stop iterating, default to 1e-3}

\item{\code{...}}{Other parameters}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
nothing
Reorder the blocks putting the "strongest" ones first in order to have
a coherent ordering of blocks with SBM and LBM for visualisation.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-reorder_parameters"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-reorder_parameters}{}}}
\subsection{Method \code{reorder_parameters()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$reorder_parameters()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; stores the new ordering
The message printed when one prints the object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-show"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-show}{}}}
\subsection{Method \code{show()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$show(type = "Fitted Collection of Bipartite SBM")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{The title above the message.
The print method}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-print"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-print}{}}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$print()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
nothing; print to console
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-plot"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-plot}{}}}
\subsection{Method \code{plot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$plot(
  type = "graphon",
  oRow = NULL,
  oCol = NULL,
  mixture = FALSE,
  net_id = NULL,
  values = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{The type of the plot. Could be "graphon", "meso" or "block".}

\item{\code{oRow}}{A reordering of the row blocks.}

\item{\code{oCol}}{A reordering of the column blocks.}

\item{\code{mixture}}{Should the block proportions of each network be plotted as
well?}

\item{\code{net_id}}{Use to plot only one network in "graphon" view.}

\item{\code{values}}{Wether or not to plot values on the alpha, pi and rho
representation.}

\item{\code{...}}{Further argument to be passed}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A plot, a ggplot2 object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fitBipartiteSBMPop-clone"></a>}}
\if{latex}{\out{\hypertarget{method-fitBipartiteSBMPop-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{fitBipartiteSBMPop$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
